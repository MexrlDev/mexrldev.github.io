<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>PS4 Poc Debug</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 18px; background:#0f1720; color:#e6eef8; }
  header { display:flex; gap:12px; align-items:center; margin-bottom:12px; }
  h1 { font-size:18px; margin:0; }
  .controls { display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:10px; margin-bottom:12px; }
  .box { background:#111827; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); }
  button { padding:8px 10px; border-radius:6px; border:0; cursor:pointer; background:#1f2937; color:#e6eef8; }
  input, select { padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:#0b1220; color:#e6eef8; width:100%; }
  pre { max-height:360px; overflow:auto; background:#020617; padding:10px; border-radius:6px; font-size:12px; line-height:1.4; }
  footer { margin-top:10px; font-size:12px; color:#9fb0c8; }
  .warn { color:#ffcccb; font-weight:600; }
</style>
</head>
<body>
<header>
  <h1>Poc Debugging</h1>
  <div style="margin-left:auto; font-size:12px; color:#9fb0c8">non-exploit / for dev only</div>
</header>

<div class="controls">
  <div class="box">
    <label><strong>Allocate arrays</strong></label>
    <div style="display:flex; gap:8px; margin-top:8px;">
      <input id="alloc-count" type="number" value="100" min="1" />
      <input id="alloc-len" type="number" value="256" min="1" />
    </div>
    <div style="display:flex; gap:8px; margin-top:8px;">
      <button id="btn-alloc">Allocate</button>
      <button id="btn-free">Free</button>
    </div>
  </div>

  <div class="box">
    <label><strong>Event & Gamepad</strong></label>
    <div style="display:flex; gap:8px; margin-top:8px;">
      <button id="btn-start-gp">Start Gamepad Poll</button>
      <button id="btn-stop-gp" disabled>Stop Poll</button>
    </div>
    <div style="margin-top:8px;">
      <button id="btn-fullscreen">Request Fullscreen</button>
      <button id="btn-exitfs">Exit Fullscreen</button>
    </div>
  </div>

  <div class="box">
    <label><strong>Logs</strong></label>
    <div style="display:flex; gap:8px; margin-top:8px;">
      <button id="btn-clear">Clear Log</button>
      <button id="btn-download">Download Log</button>
    </div>
    <div style="margin-top:8px;" class="warn">Warning: large allocations may slow or crash your browser.</div>
  </div>
</div>

<div class="box" style="margin-bottom:12px;">
  <strong>Status</strong>
  <div id="status" style="margin-top:8px; font-size:13px">Idle</div>
</div>

<div class="box">
  <strong>Debug Log</strong>
  <pre id="log" aria-live="polite"></pre>
</div>

<footer>
  By MexrlDev
</footer>

<script>
(() => {
  // Simple handwritten style logging
  const logEl = document.getElementById('log');
  const statusEl = document.getElementById('status');
  let allocs = [];
  let debugLog = [];
  let gpPollHandle = null;
  let lastGPState = null;

  function appendLog(...parts) {
    const t = new Date().toISOString();
    const line = t + '  ' + parts.join(' ');
    debugLog.push(line);
    logEl.textContent = debugLog.slice(-1000).join('\n'); // keep last 1000 lines in view
    console.log(line);
  }

  function setStatus(s) {
    statusEl.textContent = s;
    appendLog('[STATUS]', s);
  }

  // Allocation functions
  function allocate(count, len) {
    appendLog('Allocating', count, 'arrays of length', len);
    try {
      for (let i = 0; i < count; i++) {
        // Use Float64Array for numeric simulation; zero-initialized
        const a = new Float64Array(len);
        a[0] = i; // store index for trivial checksum later
        allocs.push(a);
        if ((i + 1) % 200 === 0) appendLog('  allocated', i + 1);
      }
      appendLog('Allocation complete. Total arrays:', allocs.length);
      setStatus('Allocated ' + allocs.length + ' arrays');
    } catch (err) {
      appendLog('Allocation error:', err && err.message ? err.message : err);
      setStatus('Allocation failed');
    }
  }

  function freeAll() {
    appendLog('Freeing arrays (clearing references).');
    allocs = [];
    // advise GC
    try { if (window.gc) window.gc(); } catch (e) {}
    setStatus('Freed allocations');
  }

  function checksumSummary() {
    // compute a tiny checksum across first entries to simulate integrity check
    let sum = 0;
    for (let i = 0; i < allocs.length; i++) {
      const a = allocs[i];
      if (a && a.length > 0) sum += a[0];
    }
    appendLog('Checksum summary (sum of [0] across arrays):', sum);
    return sum;
  }

  // Gamepad poll
  function pollGamepads() {
    const gps = navigator.getGamepads ? navigator.getGamepads() : [];
    let found = false;
    for (let i = 0; i < gps.length; i++) {
      const g = gps[i];
      if (!g) continue;
      found = true;
      // Report basic state â€” buttons pressed and axes
      const pressed = g.buttons.map((b, idx) => b.pressed ? idx : -1).filter(x => x >= 0);
      const axes = g.axes.map(v => Math.round(v * 100) / 100);
      const state = { idx: i, id: g.id, pressed, axes };
      // Only log changes to reduce spam
      const sjson = JSON.stringify(state);
      if (sjson !== lastGPState) {
        appendLog('Gamepad', i, 'id:', g.id || '(unknown)', 'pressed:', pressed.join(',') || '(none)', 'axes:', axes.join(','));
        lastGPState = sjson;
      }
    }
    if (!found) {
      // no gamepad connected
      // appendLog('No gamepads detected.');
    }
  }

  // Event wiring
  document.getElementById('btn-alloc').addEventListener('click', () => {
    const count = parseInt(document.getElementById('alloc-count').value, 10) || 0;
    const len = parseInt(document.getElementById('alloc-len').value, 10) || 0;
    if (count <= 0 || len <= 0) { appendLog('Invalid allocation parameters'); return; }
    allocate(count, len);
  });

  document.getElementById('btn-free').addEventListener('click', () => {
    freeAll();
  });

  document.getElementById('btn-clear').addEventListener('click', () => {
    debugLog = [];
    logEl.textContent = '';
    appendLog('Log cleared');
  });

  document.getElementById('btn-download').addEventListener('click', () => {
    const blob = new Blob([debugLog.join('\n')], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'debug-log-' + new Date().toISOString().replace(/[:.]/g,'-') + '.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    appendLog('Log downloaded');
  });

  // Fullscreen controls (safe)
  document.getElementById('btn-fullscreen').addEventListener('click', async () => {
    try {
      const el = document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      appendLog('Requested fullscreen');
    } catch (e) { appendLog('Fullscreen error:', e && e.message ? e.message : e); }
  });

  document.getElementById('btn-exitfs').addEventListener('click', async () => {
    try {
      if (document.exitFullscreen) await document.exitFullscreen();
      else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
      appendLog('Exit fullscreen requested');
    } catch (e) { appendLog('Exit fullscreen error:', e && e.message ? e.message : e); }
  });

  // Gamepad start/stop
  document.getElementById('btn-start-gp').addEventListener('click', () => {
    if (gpPollHandle) return;
    appendLog('Starting gamepad polling (250ms). Press controller buttons to see events.');
    gpPollHandle = setInterval(pollGamepads, 250);
    document.getElementById('btn-start-gp').disabled = true;
    document.getElementById('btn-stop-gp').disabled = false;
  });

  document.getElementById('btn-stop-gp').addEventListener('click', () => {
    if (!gpPollHandle) return;
    clearInterval(gpPollHandle);
    gpPollHandle = null;
    lastGPState = null;
    appendLog('Stopped gamepad polling');
    document.getElementById('btn-start-gp').disabled = false;
    document.getElementById('btn-stop-gp').disabled = true;
  });

  // Visibility and focus events for benign logging
  window.addEventListener('visibilitychange', () => {
    appendLog('visibilitychange ->', document.visibilityState);
  });

  window.addEventListener('blur', () => {
    appendLog('window blur (lost focus)');
  });

  window.addEventListener('focus', () => {
    appendLog('window focus (gained focus)');
  });

  document.addEventListener('fullscreenchange', () => {
    appendLog('fullscreenchange ->', !!document.fullscreenElement ? 'entered' : 'exited');
  });
  document.addEventListener('webkitfullscreenchange', () => {
    appendLog('webkitfullscreenchange ->', !!document.webkitFullscreenElement ? 'entered' : 'exited');
  });

  // Expose a safe API to run a checksum
  window.safeDebug = {
    checksumSummary,
    freeAll,
    getLog: () => debugLog.slice()
  };

  // initial status line
  appendLog('Safe Debugging Harness loaded');
  setStatus('Ready');
})();
</script>
</body>
</html>
